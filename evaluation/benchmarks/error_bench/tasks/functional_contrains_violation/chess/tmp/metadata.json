{
    "task_description": "\n    Use baseline.csv (a historically-clean, trusted sample from the same data source) to learn the valid patterns, value ranges, and categories for every column. Then scan to_check.csv\u2014a new batch of data\u2014to flag any cell that violates those learned rules.  You should check for functional constraints violation. Take also a look the column descriptions. They might be helpful! Return your result in a JSON format with only the following key: \n    'motivation' and the description of the corruption. If there is no corruption, return 'clean' as the value of the key 'motivation'. \n    'code_to_detect' is the code that takes as input the dataset and return the corrupted cells. This is the signature of the function:\n    def detect_corruption(df: pd.DataFrame) -> pd.DataFrame:\n        pass\n    Where the input is a pandas DataFrame and the output is a boolean DataFrame with the same shape as the input DataFrame. The function should return True for the cells that are corrupted and False for the cells that are not corrupted. DON'T BE SCARED TO EXPLORE THE DATASET! Before answering trying to list as many hypothesis as possible. Don't be afraid of listing hypothesis before answering! You should explore extensively the data before answering. You should start this task by listing all the functional dependecies that you can think of in this data and test each hypothesis you have until you find the one that is violated. Hint: take a look at stlmt\n    ",
    "dataset_description": "\n    Feature\n    Meaning (all Boolean <t/f> unless noted)\n\n    1.  bkblk   Black king is not in the way of the plan.\n    2.  bknwy   Black king is not in the white rook\u2019s way.\n    3.  bkon8   Black king sits on the 8th rank helping the rook.\n    4.  bkona   Black king sits on the a\u2011file helping the rook.\n    5.  bkspr   Black king can support its rook.\n    6.  bkxbq   Black king is safe from any attack by a promoted pawn.\n    7.  bkxcr   Black king can attack the critical square (b7).\n    8.  bkxwp   Black king can attack the white pawn on a7.\n    9.  blxwp   A Black piece attacks the white pawn from the left (x = \u20131).\n    10. bxqsq   One or more Black pieces control the queening square (a8).\n    11. cntxt   White king is on a board edge and not on a8.\n    12. dsopp   The two kings stand in normal opposition.\n    13. dwipd   White king is too far from the intersect point (files g/l).\n    14. hdchk   A hidden check gives Black a useful delaying tactic.\n    15. katri   Black king controls the intersect point (files b/n/w).\n    16. mulch   Black can renew the check to good effect.\n    17. qxmsq   The promoted pawn attacks a mating square.\n    18. r2ar8   Black rook lacks safe access to file a or rank 8.\n    19. reskd   White king can be re\u2011skewered after a delay.\n    20. reskr   Black rook alone can renew the skewer threat.\n    21. rimmx   Black rook can be captured safely.\n    22. rkxwp   Rook bears on the white pawn from the left (x = \u20131).\n    23. rxmsq   Rook safely attacks a mating square.\n    24. simpl   A very simple (trivial) pattern applies.\n    25. skach   White king can be skewered after a series of checks.\n    26. skewr   A potential skewer (not a fork) exists.\n    27. skrxp   Rook can execute a skewer or Black king attacks the pawn.\n    28. spcop   A special\u2011opposition pattern is present.\n    29. stlmt   White king is stalemated.\n    30. thrsk   A skewer threat is lurking.\n    31. wkcti   White king cannot control the intersect point.\n    32. wkna8   White king is actually on square a8.\n    33. wknck   White king is in check.\n    34. wkovl   White king is overloaded (too many duties).\n    35. wkpos   White king sits where it could be skewered.\n    36. wtoeg   White king is one square away from the edge (files n/t).\n    ",
    "correct_answer": "Functional depedency between stlmt and wknck violated",
    "percentage_of_corruption": 1
}
